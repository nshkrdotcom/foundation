    warning: module attribute @impl was not set for function start_link/1 callback (specified in Jido.Agent). This either means you forgot to add the "@impl true" annotation before the definition or that you are accidentally overriding this callback
    │
 49 │   use JidoSystem.Agents.FoundationAgent,
    │   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    │
    └─ lib/jido_system/agents/task_agent.ex:49: JidoSystem.Agents.TaskAgent (module)

    warning: module attribute @impl was not set for function start_link/1 callback (specified in Jido.Agent). This either means you forgot to add the "@impl true" annotation before the definition or that you are accidentally overriding this callback
    │
 57 │   use JidoSystem.Agents.FoundationAgent,
    │   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    │
    └─ lib/jido_system/agents/monitor_agent.ex:57: JidoSystem.Agents.MonitorAgent (module)

    warning: module attribute @impl was not set for function start_link/1 callback (specified in Jido.Agent). This either means you forgot to add the "@impl true" annotation before the definition or that you are accidentally overriding this callback
    │
 63 │   use JidoSystem.Agents.FoundationAgent,
    │   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    │
    └─ lib/jido_system/agents/coordinator_agent.ex:63: JidoSystem.Agents.CoordinatorAgent (module)

Finding suitable PLTs
Checking PLT...
[:abacus, :asn1, :backoff, :certifi, :circular_buffer, :compiler, :cowboy, :cowboy_telemetry, :cowlib, :crontab, :crypto, :deep_merge, :eex, :elixir, :ex_check, :ex_dbug, :finch, :foundation, :fuse, :gemini_ex, :gen_stage, :git_cli, :git_ops, :hackney, :hammer, :hpax, :httpoison, :idna, :jason, :jido, :jido_action, :jido_signal, :joken, :jose, :kernel, :libgraph, :logger, :meck, :metrics, :mime, :mimerl, :mint, :mox, :msgpax, :nimble_options, :nimble_ownership, :nimble_parsec, :nimble_pool, :ok, :parse_trans, ...]
PLT is up to date!
:ignore_warnings opt specified in mix.exs: .dialyzer.ignore.exs, but file does not exist.

Starting Dialyzer
[
  check_plt: false,
  init_plt: ~c"/home/home/p/g/n/elixir_ml/foundation/priv/plts/dialyzer.plt",
  files: [~c"_build/dev/lib/foundation/ebin/Elixir.MLFoundation.AgentPatterns.WorkflowCoordinator.beam",
   ~c"_build/dev/lib/foundation/ebin/Elixir.MLFoundation.DistributedOptimization.SGDWorker.beam",
   ~c"_build/dev/lib/foundation/ebin/Elixir.MLFoundation.TeamOrchestration.ValidatorAgent.beam",
   ~c"_build/dev/lib/foundation/ebin/Elixir.MLFoundation.DistributedOptimization.beam",
   ~c"_build/dev/lib/foundation/ebin/Elixir.MABEAM.AgentCoordination.beam",
   ...],
  warnings: [:error_handling, :underspecs, :unknown]
]
Total errors: 111, Skipped: 2, Unnecessary Skips: 0
done in 0m4.26s
Please file a bug in https://github.com/jeremyjh/dialyxir/issues with this message.

Failed to parse warning:
[<: 1, >: 1]


Legacy warning:
deps/jido/lib/jido/agent.ex:43: The pattern <> can never match since previous clauses completely covered the type <>
________________________________________________________________________________
deps/jido/lib/jido/agent.ex:49:unused_fun
Function do_validate/3 will never be called.
________________________________________________________________________________
deps/jido/lib/jido/agent.ex:49:unused_fun
Function enqueue_instructions/2 will never be called.
________________________________________________________________________________
deps/jido/lib/jido/agent.ex:49:pattern_match_cov
The pattern
variable_

can never match, because previous clauses completely cover the type
Keyword.t().

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:57:unused_fun
Function do_validate/3 will never be called.
________________________________________________________________________________
deps/jido/lib/jido/agent.ex:57:unused_fun
Function enqueue_instructions/2 will never be called.
________________________________________________________________________________
deps/jido/lib/jido/agent.ex:57:pattern_match_cov
The pattern
variable_

can never match, because previous clauses completely cover the type
Keyword.t().

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:63:unused_fun
Function do_validate/3 will never be called.
________________________________________________________________________________
deps/jido/lib/jido/agent.ex:63:unused_fun
Function enqueue_instructions/2 will never be called.
________________________________________________________________________________
deps/jido/lib/jido/agent.ex:63:pattern_match_cov
The pattern
variable_

can never match, because previous clauses completely cover the type
Keyword.t().

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:592:call
The function call will not succeed.

JidoSystem.Agents.CoordinatorAgent.set(_ :: %JidoSystem.Agents.CoordinatorAgent{}, _ :: map(), _ :: any())

breaks the contract
(t() | Jido.server(), :elixir.keyword() | map(), :elixir.keyword()) :: agent_result()

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:592:call
The function call will not succeed.

JidoSystem.Agents.MonitorAgent.set(_ :: %JidoSystem.Agents.MonitorAgent{}, _ :: map(), _ :: any())

breaks the contract
(t() | Jido.server(), :elixir.keyword() | map(), :elixir.keyword()) :: agent_result()

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:592:call
The function call will not succeed.

JidoSystem.Agents.TaskAgent.set(_ :: %JidoSystem.Agents.TaskAgent{}, _ :: map(), _ :: any())

breaks the contract
(t() | Jido.server(), :elixir.keyword() | map(), :elixir.keyword()) :: agent_result()

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:604:call
The function call will not succeed.

JidoSystem.Agents.CoordinatorAgent.validate(_ :: %JidoSystem.Agents.CoordinatorAgent{:state => map(), _ => _}, [
  {:strict_validation, _},
  ...
])

breaks the contract
(t() | Jido.server(), :elixir.keyword()) :: agent_result()

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:604:call
The function call will not succeed.

JidoSystem.Agents.MonitorAgent.validate(_ :: %JidoSystem.Agents.MonitorAgent{:state => map(), _ => _}, [
  {:strict_validation, _},
  ...
])

breaks the contract
(t() | Jido.server(), :elixir.keyword()) :: agent_result()

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:604:call
The function call will not succeed.

JidoSystem.Agents.TaskAgent.validate(_ :: %JidoSystem.Agents.TaskAgent{:state => map(), _ => _}, [{:strict_validation, _}, ...]) ::
  :ok
def a() do
  :ok
end

breaks the contract
(t() | Jido.server(), :elixir.keyword()) :: agent_result()

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:705:call
The function call will not succeed.

JidoSystem.Agents.CoordinatorAgent.on_before_validate_state(_ :: %JidoSystem.Agents.CoordinatorAgent{})

breaks the contract
(t()) :: agent_result()

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:705:call
The function call will not succeed.

JidoSystem.Agents.MonitorAgent.on_before_validate_state(_ :: %JidoSystem.Agents.MonitorAgent{})

breaks the contract
(t()) :: agent_result()

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:705:call
The function call will not succeed.

JidoSystem.Agents.TaskAgent.on_before_validate_state(_ :: %JidoSystem.Agents.TaskAgent{})

breaks the contract
(t()) :: agent_result()

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:846:call
The function call will not succeed.

JidoSystem.Agents.CoordinatorAgent.on_before_plan(_ :: %JidoSystem.Agents.CoordinatorAgent{}, nil, %{})

breaks the contract
(t(), Jido.Instruction.instruction_list(), map()) :: agent_result()

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:846:call
The function call will not succeed.

JidoSystem.Agents.MonitorAgent.on_before_plan(_ :: %JidoSystem.Agents.MonitorAgent{}, nil, %{})

breaks the contract
(t(), Jido.Instruction.instruction_list(), map()) :: agent_result()

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:846:call
The function call will not succeed.

JidoSystem.Agents.TaskAgent.on_before_plan(_ :: %JidoSystem.Agents.TaskAgent{}, nil, %{})

breaks the contract
(t(), Jido.Instruction.instruction_list(), map()) :: agent_result()

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:961:call
The function call will not succeed.

JidoSystem.Agents.CoordinatorAgent.on_before_run(_ :: %JidoSystem.Agents.CoordinatorAgent{})

breaks the contract
(t()) :: agent_result()

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:961:call
The function call will not succeed.

JidoSystem.Agents.MonitorAgent.on_before_run(_ :: %JidoSystem.Agents.MonitorAgent{})

breaks the contract
(t()) :: agent_result()

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:961:call
The function call will not succeed.

JidoSystem.Agents.TaskAgent.on_before_run(_ :: %JidoSystem.Agents.TaskAgent{})

breaks the contract
(t()) :: agent_result()

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:1063:call
The function call will not succeed.

JidoSystem.Agents.CoordinatorAgent.set(_ :: %JidoSystem.Agents.CoordinatorAgent{}, _ :: any(), [{:strict_validation, _}, ...]) ::
  :ok
def a() do
  :ok
end

breaks the contract
(t() | Jido.server(), :elixir.keyword() | map(), :elixir.keyword()) :: agent_result()

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:1063:call
The function call will not succeed.

JidoSystem.Agents.MonitorAgent.set(_ :: %JidoSystem.Agents.MonitorAgent{}, _ :: any(), [{:strict_validation, _}, ...])

breaks the contract
(t() | Jido.server(), :elixir.keyword() | map(), :elixir.keyword()) :: agent_result()

________________________________________________________________________________
deps/jido/lib/jido/agent.ex:1063:call
The function call will not succeed.

JidoSystem.Agents.TaskAgent.set(_ :: %JidoSystem.Agents.TaskAgent{}, _ :: any(), [{:strict_validation, _}, ...])

breaks the contract
(t() | Jido.server(), :elixir.keyword() | map(), :elixir.keyword()) :: agent_result()

________________________________________________________________________________
lib/foundation.ex:559:extra_range
The type specification has too many types for the function.

Function:
Foundation.start_link/1

Extra type:
{:error, _}

Success typing:
{:ok, pid()}

________________________________________________________________________________
lib/foundation/infrastructure/circuit_breaker.ex:310:7:callback_arg_type_mismatch
The inferred type for the 3rd argument is not a
supertype of the expected type for the register_circuit_breaker/3 callback
in the Foundation.Infrastructure behaviour.

Success type:
Keyword.t()

Behaviour callback type:
map()

________________________________________________________________________________
lib/foundation/infrastructure/circuit_breaker.ex:332:7:callback_type_mismatch
Type mismatch for @callback check_rate_limit/3 in Foundation.Infrastructure behaviour.

Expected type:
:ok | {:error, :limiter_not_found | :rate_limited}

Actual type:
{:error, :not_implemented}

________________________________________________________________________________
lib/jido_system.ex:96:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.start/1

Success typing:
@spec start(:elixir.keyword()) :: {:ok, pid()} | {:error, term()}

________________________________________________________________________________
lib/jido_system.ex:181:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.process_task/3

Extra type:
{:ok, _}

Success typing:
{:error, :server_not_found}

________________________________________________________________________________
lib/jido_system.ex:229:contract_supertype
Type specification is a supertype of the success typing.

Function:
JidoSystem.start_monitoring/1

Type specification:
@spec start_monitoring(:elixir.keyword()) :: {:ok, map()} | {:error, term()}

Success typing:
@spec start_monitoring(Keyword.t()) ::
  {:error, _}
  | {:ok,
     %{
       :configuration => map(),
       :monitor_agent => pid(),
       :sensors => map(),
       :started_at => map()
     }}

________________________________________________________________________________
lib/jido_system.ex:302:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.execute_workflow/3

Extra type:
{:ok, binary()}

Success typing:
{:error, :server_not_found}

________________________________________________________________________________
lib/jido_system.ex:347:contract_supertype
Type specification is a supertype of the success typing.

Function:
JidoSystem.get_system_status/0

Type specification:
@spec get_system_status() :: {:ok, map()} | {:error, term()}

Success typing:
@spec get_system_status() ::
  {:error, {:status_collection_failed, map()}}
  | {:ok,
     %{
       :agent_count => non_neg_integer(),
       :agents => map(),
       :health_score => number(),
       :performance_metrics => map(),
       :sensor_count => 0,
       :system_info => map(),
       :timestamp => map(),
       :uptime => non_neg_integer()
     }}

________________________________________________________________________________
lib/jido_system.ex:478:contract_supertype
Type specification is a supertype of the success typing.

Function:
JidoSystem.stop/1

Type specification:
@spec stop(:elixir.keyword()) :: :ok | {:error, term()}

Success typing:
@spec stop(Keyword.t()) ::
  :ok
  | {:error,
     {:shutdown_failed, %{:__exception__ => true, :__struct__ => atom(), atom() => _}}}

________________________________________________________________________________
lib/jido_system.ex:195:11:pattern_match
The pattern can never match the type.

Pattern:
:ok

Type:
{:error, :server_not_found} | {:ok, binary()}

________________________________________________________________________________
lib/jido_system.ex:316:11:pattern_match
The pattern can never match the type.

Pattern:
:ok

Type:
{:error, :server_not_found} | {:ok, binary()}

________________________________________________________________________________
lib/jido_system/actions/get_performance_metrics.ex:6:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Actions.GetPerformanceMetrics.run/2

Extra type:
{:error, _}

Success typing:
{:ok, %{:queue_size => non_neg_integer(), :success_rate => float(), _ => _}}

________________________________________________________________________________
lib/jido_system/actions/get_task_status.ex:6:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Actions.GetTaskStatus.run/2

Extra type:
{:error, _}

Success typing:

  {:ok,
   %{
     :current_task => _,
     :error_count => _,
     :performance_metrics => _,
     :processed_count => _,
     :queue_size => non_neg_integer(),
     :status => _,
     :uptime => integer()
   }}


________________________________________________________________________________
lib/jido_system/actions/pause_processing.ex:6:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Actions.PauseProcessing.run/2

Extra type:
{:error, _}

Success typing:

  {:ok,
   %{
     :paused_at => %DateTime{
       :calendar => atom(),
       :day => pos_integer(),
       :hour => non_neg_integer(),
       :microsecond => {_, _},
       :minute => non_neg_integer(),
       :month => pos_integer(),
       :second => non_neg_integer(),
       :std_offset => integer(),
       :time_zone => binary(),
       :utc_offset => integer(),
       :year => integer(),
       :zone_abbr => binary()
     },
     :previous_status => _,
     :reason => _,
     :status => :paused
   }}


________________________________________________________________________________
lib/jido_system/actions/resume_processing.ex:6:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Actions.ResumeProcessing.run/2

Extra type:
{:error, _}

Success typing:

  {:ok,
   %{
     :previous_status => _,
     :resumed_at => %DateTime{
       :calendar => atom(),
       :day => pos_integer(),
       :hour => non_neg_integer(),
       :microsecond => {_, _},
       :minute => non_neg_integer(),
       :month => pos_integer(),
       :second => non_neg_integer(),
       :std_offset => integer(),
       :time_zone => binary(),
       :utc_offset => integer(),
       :year => integer(),
       :zone_abbr => binary()
     },
     :status => :idle
   }}


________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:63:callback_spec_arg_type_mismatch
The @spec type for the 1st argument is not a
supertype of the expected type for the mount/2 callback
in the Jido.Agent behaviour.

Success type:
%Jido.Agent.Server.State{
  :agent => %Jido.Agent{
    :actions => [atom()],
    :category => nil | binary(),
    :description => nil | binary(),
    :dirty_state? => boolean(),
    :id => nil | binary(),
    :name => nil | binary(),
    :pending_instructions => nil | :queue.queue(_),
    :result => _,
    :runner => atom(),
    :schema => nil | Keyword.t(),
    :state => map(),
    :tags => nil | [binary()],
    :vsn => nil | binary()
  },
  :child_supervisor => nil | pid(),
  :current_signal => %Jido.Signal{
    :data => _,
    :datacontenttype => nil | binary(),
    :dataschema => nil | binary(),
    :id => binary(),
    :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
    :source => binary(),
    :specversion => binary(),
    :subject => nil | binary(),
    :time => nil | binary(),
    :type => binary()
  },
  :current_signal_type => atom(),
  :dispatch => [
    {:err, {atom(), Keyword.t()}}
    | {:log, {atom(), Keyword.t()}}
    | {:out, {atom(), Keyword.t()}}
  ],
  :journal => %Jido.Signal.Journal{:adapter => atom(), :adapter_pid => nil | pid()},
  :log_level =>
    :alert | :critical | :debug | :emergency | :error | :info | :notice | :warning,
  :max_queue_size => non_neg_integer(),
  :mode => :auto | :step,
  :opts => Keyword.t(),
  :orchestrator_pid => nil | pid(),
  :parent_pid => nil | pid(),
  :pending_signals => :queue.queue(_),
  :registry => atom(),
  :reply_refs => %{binary() => {pid(), _}},
  :router => %Jido.Signal.Router.Router{
    :route_count => non_neg_integer(),
    :trie => %Jido.Signal.Router.TrieNode{
      :handlers =>
        nil
        | %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
      :segments => %{
        binary() => %Jido.Signal.Router.TrieNode{
          :handlers => nil | map(),
          :segments => map(),
          :wildcards => [any()],
          _ => _
        }
      },
      :wildcards => [
        %Jido.Signal.Router.WildcardHandlers{
          :handlers => %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
          :type => :multi | :single
        }
      ]
    }
  },
  :skills => [
    %Jido.Skill{
      :category => nil | binary(),
      :description => nil | binary(),
      :name => binary(),
      :opts_key => atom(),
      :opts_schema => nil | map(),
      :signal_patterns => [binary()],
      :tags => [binary()],
      :vsn => nil | binary()
    }
  ],
  :status => :idle | :initializing | :paused | :planning | :running
}

Behaviour callback type:
%Jido.Agent{
  :actions => [atom()],
  :category => nil | binary(),
  :description => nil | binary(),
  :dirty_state? => boolean(),
  :id => nil | binary(),
  :name => nil | binary(),
  :pending_instructions => nil | :queue.queue(_),
  :result => _,
  :runner => atom(),
  :schema => nil | Keyword.t(),
  :state => map(),
  :tags => nil | [binary()],
  :vsn => nil | binary()
}

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:63:callback_spec_arg_type_mismatch
The @spec type for the 1st argument is not a
supertype of the expected type for the shutdown/2 callback
in the Jido.Agent behaviour.

Success type:
%Jido.Agent.Server.State{
  :agent => %Jido.Agent{
    :actions => [atom()],
    :category => nil | binary(),
    :description => nil | binary(),
    :dirty_state? => boolean(),
    :id => nil | binary(),
    :name => nil | binary(),
    :pending_instructions => nil | :queue.queue(_),
    :result => _,
    :runner => atom(),
    :schema => nil | Keyword.t(),
    :state => map(),
    :tags => nil | [binary()],
    :vsn => nil | binary()
  },
  :child_supervisor => nil | pid(),
  :current_signal => %Jido.Signal{
    :data => _,
    :datacontenttype => nil | binary(),
    :dataschema => nil | binary(),
    :id => binary(),
    :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
    :source => binary(),
    :specversion => binary(),
    :subject => nil | binary(),
    :time => nil | binary(),
    :type => binary()
  },
  :current_signal_type => atom(),
  :dispatch => [
    {:err, {atom(), Keyword.t()}}
    | {:log, {atom(), Keyword.t()}}
    | {:out, {atom(), Keyword.t()}}
  ],
  :journal => %Jido.Signal.Journal{:adapter => atom(), :adapter_pid => nil | pid()},
  :log_level =>
    :alert | :critical | :debug | :emergency | :error | :info | :notice | :warning,
  :max_queue_size => non_neg_integer(),
  :mode => :auto | :step,
  :opts => Keyword.t(),
  :orchestrator_pid => nil | pid(),
  :parent_pid => nil | pid(),
  :pending_signals => :queue.queue(_),
  :registry => atom(),
  :reply_refs => %{binary() => {pid(), _}},
  :router => %Jido.Signal.Router.Router{
    :route_count => non_neg_integer(),
    :trie => %Jido.Signal.Router.TrieNode{
      :handlers =>
        nil
        | %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
      :segments => %{
        binary() => %Jido.Signal.Router.TrieNode{
          :handlers => nil | map(),
          :segments => map(),
          :wildcards => [any()],
          _ => _
        }
      },
      :wildcards => [
        %Jido.Signal.Router.WildcardHandlers{
          :handlers => %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
          :type => :multi | :single
        }
      ]
    }
  },
  :skills => [
    %Jido.Skill{
      :category => nil | binary(),
      :description => nil | binary(),
      :name => binary(),
      :opts_key => atom(),
      :opts_schema => nil | map(),
      :signal_patterns => [binary()],
      :tags => [binary()],
      :vsn => nil | binary()
    }
  ],
  :status => :idle | :initializing | :paused | :planning | :running
}

Behaviour callback type:
%Jido.Agent{
  :actions => [atom()],
  :category => nil | binary(),
  :description => nil | binary(),
  :dirty_state? => boolean(),
  :id => nil | binary(),
  :name => nil | binary(),
  :pending_instructions => nil | :queue.queue(_),
  :result => _,
  :runner => atom(),
  :schema => nil | Keyword.t(),
  :state => map(),
  :tags => nil | [binary()],
  :vsn => nil | binary()
}

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:63:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.CoordinatorAgent.do_validate/3

Success typing:
@spec do_validate(t(), map(), :elixir.keyword()) :: map_result()

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:63:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Agents.CoordinatorAgent.handle_signal/2

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:63:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.CoordinatorAgent.on_error/2

Success typing:
@spec on_error(t(), any()) :: agent_result()

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:63:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.CoordinatorAgent.pending?/1

Success typing:
@spec pending?(t()) :: non_neg_integer()

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:63:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.CoordinatorAgent.reset/1

Success typing:
@spec reset(t()) :: agent_result()

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:63:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Agents.CoordinatorAgent.transform_result/3

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:143:7:pattern_match_cov
The pattern
variable_error

can never match, because previous clauses completely cover the type
{:ok, _}.

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:511:15:pattern_match
The pattern can never match the type.

Pattern:
:failed

Type:
:cancelled

________________________________________________________________________________
lib/jido_system/agents/foundation_agent.ex:57:callback_type_mismatch
Type mismatch for @callback on_error/2 in Jido.Agent behaviour.

Expected type:

  {:error,
   %Jido.Agent{
     :actions => [atom()],
     :category => nil | binary(),
     :description => nil | binary(),
     :dirty_state? => boolean(),
     :id => nil | binary(),
     :name => nil | binary(),
     :pending_instructions => nil | :queue.queue(_),
     :result => _,
     :runner => atom(),
     :schema => nil | Keyword.t(),
     :state => map(),
     :tags => nil | [binary()],
     :vsn => nil | binary()
   }}
  | {:ok,
     %Jido.Agent{
       :actions => [atom()],
       :category => nil | binary(),
       :description => nil | binary(),
       :dirty_state? => boolean(),
       :id => nil | binary(),
       :name => nil | binary(),
       :pending_instructions => nil | :queue.queue(_),
       :result => _,
       :runner => atom(),
       :schema => nil | Keyword.t(),
       :state => map(),
       :tags => nil | [binary()],
       :vsn => nil | binary()
     }}


Actual type:
{:ok, %{:state => %{:status => :recovering, _ => _}, _ => _}, []}

________________________________________________________________________________
lib/jido_system/agents/foundation_agent.ex:63:callback_type_mismatch
Type mismatch for @callback on_error/2 in Jido.Agent behaviour.

Expected type:

  {:error,
   %Jido.Agent{
     :actions => [atom()],
     :category => nil | binary(),
     :description => nil | binary(),
     :dirty_state? => boolean(),
     :id => nil | binary(),
     :name => nil | binary(),
     :pending_instructions => nil | :queue.queue(_),
     :result => _,
     :runner => atom(),
     :schema => nil | Keyword.t(),
     :state => map(),
     :tags => nil | [binary()],
     :vsn => nil | binary()
   }}
  | {:ok,
     %Jido.Agent{
       :actions => [atom()],
       :category => nil | binary(),
       :description => nil | binary(),
       :dirty_state? => boolean(),
       :id => nil | binary(),
       :name => nil | binary(),
       :pending_instructions => nil | :queue.queue(_),
       :result => _,
       :runner => atom(),
       :schema => nil | Keyword.t(),
       :state => map(),
       :tags => nil | [binary()],
       :vsn => nil | binary()
     }}


Actual type:
{:ok, %{:state => %{:status => :recovering, _ => _}, _ => _}, []}

________________________________________________________________________________
lib/jido_system/agents/foundation_agent.ex:239:pattern_match
The pattern can never match the type.

Pattern:
JidoSystem.Agents.TaskAgent

Type:
JidoSystem.Agents.CoordinatorAgent

________________________________________________________________________________
lib/jido_system/agents/foundation_agent.ex:239:pattern_match
The pattern can never match the type.

Pattern:
JidoSystem.Agents.TaskAgent

Type:
JidoSystem.Agents.MonitorAgent

________________________________________________________________________________
lib/jido_system/agents/foundation_agent.ex:240:pattern_match
The pattern can never match the type.

Pattern:
JidoSystem.Agents.MonitorAgent

Type:
JidoSystem.Agents.CoordinatorAgent

________________________________________________________________________________
lib/jido_system/agents/foundation_agent.ex:240:pattern_match
The pattern can never match the type.

Pattern:
JidoSystem.Agents.MonitorAgent

Type:
JidoSystem.Agents.TaskAgent

________________________________________________________________________________
lib/jido_system/agents/foundation_agent.ex:241:pattern_match
The pattern can never match the type.

Pattern:
JidoSystem.Agents.CoordinatorAgent

Type:
JidoSystem.Agents.MonitorAgent

________________________________________________________________________________
lib/jido_system/agents/foundation_agent.ex:241:pattern_match
The pattern can never match the type.

Pattern:
JidoSystem.Agents.CoordinatorAgent

Type:
JidoSystem.Agents.TaskAgent

________________________________________________________________________________
lib/jido_system/agents/foundation_agent.ex:242:pattern_match_cov
The pattern
:variable_

can never match, because previous clauses completely cover the type
JidoSystem.Agents.CoordinatorAgent.

________________________________________________________________________________
lib/jido_system/agents/foundation_agent.ex:242:pattern_match_cov
The pattern
:variable_

can never match, because previous clauses completely cover the type
JidoSystem.Agents.MonitorAgent.

________________________________________________________________________________
lib/jido_system/agents/foundation_agent.ex:242:pattern_match_cov
The pattern
:variable_

can never match, because previous clauses completely cover the type
JidoSystem.Agents.TaskAgent.

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:57:callback_spec_arg_type_mismatch
The @spec type for the 1st argument is not a
supertype of the expected type for the mount/2 callback
in the Jido.Agent behaviour.

Success type:
%Jido.Agent.Server.State{
  :agent => %Jido.Agent{
    :actions => [atom()],
    :category => nil | binary(),
    :description => nil | binary(),
    :dirty_state? => boolean(),
    :id => nil | binary(),
    :name => nil | binary(),
    :pending_instructions => nil | :queue.queue(_),
    :result => _,
    :runner => atom(),
    :schema => nil | Keyword.t(),
    :state => map(),
    :tags => nil | [binary()],
    :vsn => nil | binary()
  },
  :child_supervisor => nil | pid(),
  :current_signal => %Jido.Signal{
    :data => _,
    :datacontenttype => nil | binary(),
    :dataschema => nil | binary(),
    :id => binary(),
    :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
    :source => binary(),
    :specversion => binary(),
    :subject => nil | binary(),
    :time => nil | binary(),
    :type => binary()
  },
  :current_signal_type => atom(),
  :dispatch => [
    {:err, {atom(), Keyword.t()}}
    | {:log, {atom(), Keyword.t()}}
    | {:out, {atom(), Keyword.t()}}
  ],
  :journal => %Jido.Signal.Journal{:adapter => atom(), :adapter_pid => nil | pid()},
  :log_level =>
    :alert | :critical | :debug | :emergency | :error | :info | :notice | :warning,
  :max_queue_size => non_neg_integer(),
  :mode => :auto | :step,
  :opts => Keyword.t(),
  :orchestrator_pid => nil | pid(),
  :parent_pid => nil | pid(),
  :pending_signals => :queue.queue(_),
  :registry => atom(),
  :reply_refs => %{binary() => {pid(), _}},
  :router => %Jido.Signal.Router.Router{
    :route_count => non_neg_integer(),
    :trie => %Jido.Signal.Router.TrieNode{
      :handlers =>
        nil
        | %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
      :segments => %{
        binary() => %Jido.Signal.Router.TrieNode{
          :handlers => nil | map(),
          :segments => map(),
          :wildcards => [any()],
          _ => _
        }
      },
      :wildcards => [
        %Jido.Signal.Router.WildcardHandlers{
          :handlers => %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
          :type => :multi | :single
        }
      ]
    }
  },
  :skills => [
    %Jido.Skill{
      :category => nil | binary(),
      :description => nil | binary(),
      :name => binary(),
      :opts_key => atom(),
      :opts_schema => nil | map(),
      :signal_patterns => [binary()],
      :tags => [binary()],
      :vsn => nil | binary()
    }
  ],
  :status => :idle | :initializing | :paused | :planning | :running
}

Behaviour callback type:
%Jido.Agent{
  :actions => [atom()],
  :category => nil | binary(),
  :description => nil | binary(),
  :dirty_state? => boolean(),
  :id => nil | binary(),
  :name => nil | binary(),
  :pending_instructions => nil | :queue.queue(_),
  :result => _,
  :runner => atom(),
  :schema => nil | Keyword.t(),
  :state => map(),
  :tags => nil | [binary()],
  :vsn => nil | binary()
}

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:57:callback_spec_arg_type_mismatch
The @spec type for the 1st argument is not a
supertype of the expected type for the shutdown/2 callback
in the Jido.Agent behaviour.

Success type:
%Jido.Agent.Server.State{
  :agent => %Jido.Agent{
    :actions => [atom()],
    :category => nil | binary(),
    :description => nil | binary(),
    :dirty_state? => boolean(),
    :id => nil | binary(),
    :name => nil | binary(),
    :pending_instructions => nil | :queue.queue(_),
    :result => _,
    :runner => atom(),
    :schema => nil | Keyword.t(),
    :state => map(),
    :tags => nil | [binary()],
    :vsn => nil | binary()
  },
  :child_supervisor => nil | pid(),
  :current_signal => %Jido.Signal{
    :data => _,
    :datacontenttype => nil | binary(),
    :dataschema => nil | binary(),
    :id => binary(),
    :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
    :source => binary(),
    :specversion => binary(),
    :subject => nil | binary(),
    :time => nil | binary(),
    :type => binary()
  },
  :current_signal_type => atom(),
  :dispatch => [
    {:err, {atom(), Keyword.t()}}
    | {:log, {atom(), Keyword.t()}}
    | {:out, {atom(), Keyword.t()}}
  ],
  :journal => %Jido.Signal.Journal{:adapter => atom(), :adapter_pid => nil | pid()},
  :log_level =>
    :alert | :critical | :debug | :emergency | :error | :info | :notice | :warning,
  :max_queue_size => non_neg_integer(),
  :mode => :auto | :step,
  :opts => Keyword.t(),
  :orchestrator_pid => nil | pid(),
  :parent_pid => nil | pid(),
  :pending_signals => :queue.queue(_),
  :registry => atom(),
  :reply_refs => %{binary() => {pid(), _}},
  :router => %Jido.Signal.Router.Router{
    :route_count => non_neg_integer(),
    :trie => %Jido.Signal.Router.TrieNode{
      :handlers =>
        nil
        | %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
      :segments => %{
        binary() => %Jido.Signal.Router.TrieNode{
          :handlers => nil | map(),
          :segments => map(),
          :wildcards => [any()],
          _ => _
        }
      },
      :wildcards => [
        %Jido.Signal.Router.WildcardHandlers{
          :handlers => %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
          :type => :multi | :single
        }
      ]
    }
  },
  :skills => [
    %Jido.Skill{
      :category => nil | binary(),
      :description => nil | binary(),
      :name => binary(),
      :opts_key => atom(),
      :opts_schema => nil | map(),
      :signal_patterns => [binary()],
      :tags => [binary()],
      :vsn => nil | binary()
    }
  ],
  :status => :idle | :initializing | :paused | :planning | :running
}

Behaviour callback type:
%Jido.Agent{
  :actions => [atom()],
  :category => nil | binary(),
  :description => nil | binary(),
  :dirty_state? => boolean(),
  :id => nil | binary(),
  :name => nil | binary(),
  :pending_instructions => nil | :queue.queue(_),
  :result => _,
  :runner => atom(),
  :schema => nil | Keyword.t(),
  :state => map(),
  :tags => nil | [binary()],
  :vsn => nil | binary()
}

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:57:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.MonitorAgent.do_validate/3

Success typing:
@spec do_validate(t(), map(), :elixir.keyword()) :: map_result()

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:57:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Agents.MonitorAgent.handle_signal/2

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:57:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.MonitorAgent.on_error/2

Success typing:
@spec on_error(t(), any()) :: agent_result()

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:57:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.MonitorAgent.pending?/1

Success typing:
@spec pending?(t()) :: non_neg_integer()

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:57:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.MonitorAgent.reset/1

Success typing:
@spec reset(t()) :: agent_result()

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:57:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Agents.MonitorAgent.transform_result/3

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:136:7:pattern_match_cov
The pattern
variable_error

can never match, because previous clauses completely cover the type
{:ok, _}.

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:373:46:no_return
The created anonymous function has no local return.
________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:375:11:pattern_match
The pattern can never match the type.

Pattern:
[{_pid, _metadata}]

Type:
:error | {:ok, {pid(), map()}}

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:384:12:pattern_match
The pattern can never match the type.

Pattern:
[]

Type:
:error | {:ok, {pid(), map()}}

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:412:7:pattern_match_cov
The pattern
:variable_

can never match, because previous clauses completely cover the type
binary().

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:49:callback_spec_arg_type_mismatch
The @spec type for the 1st argument is not a
supertype of the expected type for the mount/2 callback
in the Jido.Agent behaviour.

Success type:
%Jido.Agent.Server.State{
  :agent => %Jido.Agent{
    :actions => [atom()],
    :category => nil | binary(),
    :description => nil | binary(),
    :dirty_state? => boolean(),
    :id => nil | binary(),
    :name => nil | binary(),
    :pending_instructions => nil | :queue.queue(_),
    :result => _,
    :runner => atom(),
    :schema => nil | Keyword.t(),
    :state => map(),
    :tags => nil | [binary()],
    :vsn => nil | binary()
  },
  :child_supervisor => nil | pid(),
  :current_signal => %Jido.Signal{
    :data => _,
    :datacontenttype => nil | binary(),
    :dataschema => nil | binary(),
    :id => binary(),
    :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
    :source => binary(),
    :specversion => binary(),
    :subject => nil | binary(),
    :time => nil | binary(),
    :type => binary()
  },
  :current_signal_type => atom(),
  :dispatch => [
    {:err, {atom(), Keyword.t()}}
    | {:log, {atom(), Keyword.t()}}
    | {:out, {atom(), Keyword.t()}}
  ],
  :journal => %Jido.Signal.Journal{:adapter => atom(), :adapter_pid => nil | pid()},
  :log_level =>
    :alert | :critical | :debug | :emergency | :error | :info | :notice | :warning,
  :max_queue_size => non_neg_integer(),
  :mode => :auto | :step,
  :opts => Keyword.t(),
  :orchestrator_pid => nil | pid(),
  :parent_pid => nil | pid(),
  :pending_signals => :queue.queue(_),
  :registry => atom(),
  :reply_refs => %{binary() => {pid(), _}},
  :router => %Jido.Signal.Router.Router{
    :route_count => non_neg_integer(),
    :trie => %Jido.Signal.Router.TrieNode{
      :handlers =>
        nil
        | %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
      :segments => %{
        binary() => %Jido.Signal.Router.TrieNode{
          :handlers => nil | map(),
          :segments => map(),
          :wildcards => [any()],
          _ => _
        }
      },
      :wildcards => [
        %Jido.Signal.Router.WildcardHandlers{
          :handlers => %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
          :type => :multi | :single
        }
      ]
    }
  },
  :skills => [
    %Jido.Skill{
      :category => nil | binary(),
      :description => nil | binary(),
      :name => binary(),
      :opts_key => atom(),
      :opts_schema => nil | map(),
      :signal_patterns => [binary()],
      :tags => [binary()],
      :vsn => nil | binary()
    }
  ],
  :status => :idle | :initializing | :paused | :planning | :running
}

Behaviour callback type:
%Jido.Agent{
  :actions => [atom()],
  :category => nil | binary(),
  :description => nil | binary(),
  :dirty_state? => boolean(),
  :id => nil | binary(),
  :name => nil | binary(),
  :pending_instructions => nil | :queue.queue(_),
  :result => _,
  :runner => atom(),
  :schema => nil | Keyword.t(),
  :state => map(),
  :tags => nil | [binary()],
  :vsn => nil | binary()
}

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:49:callback_spec_arg_type_mismatch
The @spec type for the 1st argument is not a
supertype of the expected type for the shutdown/2 callback
in the Jido.Agent behaviour.

Success type:
%Jido.Agent.Server.State{
  :agent => %Jido.Agent{
    :actions => [atom()],
    :category => nil | binary(),
    :description => nil | binary(),
    :dirty_state? => boolean(),
    :id => nil | binary(),
    :name => nil | binary(),
    :pending_instructions => nil | :queue.queue(_),
    :result => _,
    :runner => atom(),
    :schema => nil | Keyword.t(),
    :state => map(),
    :tags => nil | [binary()],
    :vsn => nil | binary()
  },
  :child_supervisor => nil | pid(),
  :current_signal => %Jido.Signal{
    :data => _,
    :datacontenttype => nil | binary(),
    :dataschema => nil | binary(),
    :id => binary(),
    :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
    :source => binary(),
    :specversion => binary(),
    :subject => nil | binary(),
    :time => nil | binary(),
    :type => binary()
  },
  :current_signal_type => atom(),
  :dispatch => [
    {:err, {atom(), Keyword.t()}}
    | {:log, {atom(), Keyword.t()}}
    | {:out, {atom(), Keyword.t()}}
  ],
  :journal => %Jido.Signal.Journal{:adapter => atom(), :adapter_pid => nil | pid()},
  :log_level =>
    :alert | :critical | :debug | :emergency | :error | :info | :notice | :warning,
  :max_queue_size => non_neg_integer(),
  :mode => :auto | :step,
  :opts => Keyword.t(),
  :orchestrator_pid => nil | pid(),
  :parent_pid => nil | pid(),
  :pending_signals => :queue.queue(_),
  :registry => atom(),
  :reply_refs => %{binary() => {pid(), _}},
  :router => %Jido.Signal.Router.Router{
    :route_count => non_neg_integer(),
    :trie => %Jido.Signal.Router.TrieNode{
      :handlers =>
        nil
        | %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
      :segments => %{
        binary() => %Jido.Signal.Router.TrieNode{
          :handlers => nil | map(),
          :segments => map(),
          :wildcards => [any()],
          _ => _
        }
      },
      :wildcards => [
        %Jido.Signal.Router.WildcardHandlers{
          :handlers => %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
          :type => :multi | :single
        }
      ]
    }
  },
  :skills => [
    %Jido.Skill{
      :category => nil | binary(),
      :description => nil | binary(),
      :name => binary(),
      :opts_key => atom(),
      :opts_schema => nil | map(),
      :signal_patterns => [binary()],
      :tags => [binary()],
      :vsn => nil | binary()
    }
  ],
  :status => :idle | :initializing | :paused | :planning | :running
}

Behaviour callback type:
%Jido.Agent{
  :actions => [atom()],
  :category => nil | binary(),
  :description => nil | binary(),
  :dirty_state? => boolean(),
  :id => nil | binary(),
  :name => nil | binary(),
  :pending_instructions => nil | :queue.queue(_),
  :result => _,
  :runner => atom(),
  :schema => nil | Keyword.t(),
  :state => map(),
  :tags => nil | [binary()],
  :vsn => nil | binary()
}

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:49:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.TaskAgent.do_validate/3

Success typing:
@spec do_validate(t(), map(), :elixir.keyword()) :: map_result()

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:49:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Agents.TaskAgent.handle_signal/2

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:49:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.TaskAgent.on_error/2

Success typing:
@spec on_error(t(), any()) :: agent_result()

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:49:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.TaskAgent.pending?/1

Success typing:
@spec pending?(t()) :: non_neg_integer()

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:49:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.TaskAgent.reset/1

Success typing:
@spec reset(t()) :: agent_result()

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:49:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Agents.TaskAgent.transform_result/3

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:116:7:pattern_match_cov
The pattern
variable_error

can never match, because previous clauses completely cover the type
{:ok, _}.

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:190:7:pattern_match_cov
The pattern
variable_error

can never match, because previous clauses completely cover the type
{:ok, _}.

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:196:7:callback_type_mismatch
Type mismatch for @callback on_error/2 in Jido.Agent behaviour.

Expected type:

  {:error,
   %Jido.Agent{
     :actions => [atom()],
     :category => nil | binary(),
     :description => nil | binary(),
     :dirty_state? => boolean(),
     :id => nil | binary(),
     :name => nil | binary(),
     :pending_instructions => nil | :queue.queue(_),
     :result => _,
     :runner => atom(),
     :schema => nil | Keyword.t(),
     :state => map(),
     :tags => nil | [binary()],
     :vsn => nil | binary()
   }}
  | {:ok,
     %Jido.Agent{
       :actions => [atom()],
       :category => nil | binary(),
       :description => nil | binary(),
       :dirty_state? => boolean(),
       :id => nil | binary(),
       :name => nil | binary(),
       :pending_instructions => nil | :queue.queue(_),
       :result => _,
       :runner => atom(),
       :schema => nil | Keyword.t(),
       :state => map(),
       :tags => nil | [binary()],
       :vsn => nil | binary()
     }}


Actual type:

  {:ok,
   %{
     :state => %{
       :current_task => nil,
       :error_count => _,
       :status => :idle | :paused | :recovering,
       _ => _
     },
     _ => _
   }, []}


________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:232:7:pattern_match_cov
The pattern
variable_error

can never match, because previous clauses completely cover the type
{:ok, %{:state => %{:status => :recovering, _ => _}, _ => _}, []}.

________________________________________________________________________________
lib/jido_system/sensors/agent_performance_sensor.ex:32:contract_supertype
Type specification is a supertype of the success typing.

Function:
JidoSystem.Sensors.AgentPerformanceSensor.__sensor_metadata__/0

Type specification:
@spec __sensor_metadata__() :: map()

Success typing:
@spec __sensor_metadata__() :: %{:category => _, :description => _, :name => _, :schema => _, :tags => _, :vsn => _}

________________________________________________________________________________
lib/jido_system/sensors/agent_performance_sensor.ex:32:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Sensors.AgentPerformanceSensor.deliver_signal/1

Success typing:
@spec deliver_signal(map()) :: {:ok, Jido.Signal.t()} | {:error, any()}

________________________________________________________________________________
lib/jido_system/sensors/agent_performance_sensor.ex:32:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Sensors.AgentPerformanceSensor.mount/1

Extra type:
{:error, _}

Success typing:

  {:ok,
   %{
     :agent_metrics => %{},
     :last_analysis => %DateTime{
       :calendar => atom(),
       :day => pos_integer(),
       :hour => non_neg_integer(),
       :microsecond => {_, _},
       :minute => non_neg_integer(),
       :month => pos_integer(),
       :second => non_neg_integer(),
       :std_offset => integer(),
       :time_zone => binary(),
       :utc_offset => integer(),
       :year => integer(),
       :zone_abbr => binary()
     },
     :optimization_suggestions => %{},
     :performance_history => %{},
     :started_at => %DateTime{
       :calendar => atom(),
       :day => pos_integer(),
       :hour => non_neg_integer(),
       :microsecond => {_, _},
       :minute => non_neg_integer(),
       :month => pos_integer(),
       :second => non_neg_integer(),
       :std_offset => integer(),
       :time_zone => binary(),
       :utc_offset => integer(),
       :year => integer(),
       :zone_abbr => binary()
     },
     :monitoring_interval => non_neg_integer(),
     _ => _
   }}


________________________________________________________________________________
lib/jido_system/sensors/agent_performance_sensor.ex:32:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Sensors.AgentPerformanceSensor.on_before_deliver/2

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/sensors/agent_performance_sensor.ex:32:unknown_type
Unknown type: Jido.Sensor.sensor_result/0.
________________________________________________________________________________
lib/jido_system/sensors/agent_performance_sensor.ex:32:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Sensors.AgentPerformanceSensor.shutdown/1

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/sensors/agent_performance_sensor.ex:32:contract_supertype
Type specification is a supertype of the success typing.

Function:
JidoSystem.Sensors.AgentPerformanceSensor.to_json/0

Type specification:
@spec to_json() :: map()

Success typing:
@spec to_json() :: %{:category => _, :description => _, :name => _, :schema => _, :tags => _, :vsn => _}

________________________________________________________________________________
lib/jido_system/sensors/agent_performance_sensor.ex:81:7:callback_type_mismatch
Type mismatch for @callback deliver_signal/1 in Jido.Sensor behaviour.

Expected type:

  {:error, _}
  | {:ok,
     %Jido.Signal{
       :data => _,
       :datacontenttype => nil | binary(),
       :dataschema => nil | binary(),
       :id => binary(),
       :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
       :source => binary(),
       :specversion => binary(),
       :subject => nil | binary(),
       :time => nil | binary(),
       :type => binary()
     }}


Actual type:

  {:ok,
   {:error, <<_::64, _::size(8)>>}
   | {:ok,
      %Jido.Signal{
        :data => _,
        :datacontenttype => nil | binary(),
        :dataschema => nil | binary(),
        :id => binary(),
        :jido_dispatch => nil | [any()] | {_, _},
        :source => binary(),
        :specversion => <<_::40>>,
        :subject => nil | binary(),
        :time => nil | binary(),
        :type => binary()
      }}, _}


________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:49:contract_supertype
Type specification is a supertype of the success typing.

Function:
JidoSystem.Sensors.SystemHealthSensor.__sensor_metadata__/0

Type specification:
@spec __sensor_metadata__() :: map()

Success typing:
@spec __sensor_metadata__() :: %{:category => _, :description => _, :name => _, :schema => _, :tags => _, :vsn => _}

________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:49:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Sensors.SystemHealthSensor.deliver_signal/1

Extra type:
{:error, _}

Success typing:

  {:ok,
   {:error, <<_::64, _::size(8)>>}
   | {:ok,
      %Jido.Signal{
        :data => _,
        :datacontenttype => nil | binary(),
        :dataschema => nil | binary(),
        :id => binary(),
        :jido_dispatch => nil | [any()] | {_, _},
        :source => binary(),
        :specversion => <<_::40>>,
        :subject => nil | binary(),
        :time => nil | binary(),
        :type => binary()
      }}
   | %Jido.Signal{
       :data => _,
       :datacontenttype => nil | binary(),
       :dataschema => nil | binary(),
       :id => binary(),
       :jido_dispatch => nil | [{_, _}] | {atom(), [any()]},
       :source => binary(),
       :specversion => <<_::40>>,
       :subject => nil | binary(),
       :time => nil | binary(),
       :type => binary()
     }}


________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:49:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Sensors.SystemHealthSensor.mount/1

Extra type:
{:error, _}

Success typing:

  {:ok,
   %{
     :alert_cooldown => _,
     :baseline_metrics => %{},
     :collection_count => 0,
     :collection_interval => non_neg_integer(),
     :enable_anomaly_detection => _,
     :history_size => _,
     :last_alerts => %{},
     :last_metrics => %{},
     :metrics_history => [],
     :started_at => %DateTime{
       :calendar => atom(),
       :day => pos_integer(),
       :hour => non_neg_integer(),
       :microsecond => {_, _},
       :minute => non_neg_integer(),
       :month => pos_integer(),
       :second => non_neg_integer(),
       :std_offset => integer(),
       :time_zone => binary(),
       :utc_offset => integer(),
       :year => integer(),
       :zone_abbr => binary()
     },
     :thresholds => _,
     _ => _
   }}


________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:49:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Sensors.SystemHealthSensor.on_before_deliver/2

Success typing:
@spec on_before_deliver(Jido.Signal.t(), map()) :: {:ok, Jido.Signal.t()} | {:error, any()}

________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:49:unknown_type
Unknown type: Jido.Sensor.sensor_result/0.
________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:49:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Sensors.SystemHealthSensor.shutdown/1

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:49:contract_supertype
Type specification is a supertype of the success typing.

Function:
JidoSystem.Sensors.SystemHealthSensor.to_json/0

Type specification:
@spec to_json() :: map()

Success typing:
@spec to_json() :: %{:category => _, :description => _, :name => _, :schema => _, :tags => _, :vsn => _}

________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:166:7:callback_type_mismatch
Type mismatch for @callback on_before_deliver/2 in Jido.Sensor behaviour.

Expected type:

  {:error, _}
  | {:ok,
     %Jido.Signal{
       :data => _,
       :datacontenttype => nil | binary(),
       :dataschema => nil | binary(),
       :id => binary(),
       :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
       :source => binary(),
       :specversion => binary(),
       :subject => nil | binary(),
       :time => nil | binary(),
       :type => binary()
     }}


Actual type:
%{
  :data => %{:collection_count => _, :sensor_id => _, :sensor_uptime => integer(), _ => _},
  _ => _
}

________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:564:8:pattern_match_cov
The pattern
variable_scheduler_utilization

can never match, because previous clauses completely cover the type
[].

________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:578:8:pattern_match_cov
The pattern
variable__invalid_data

can never match, because previous clauses completely cover the type
[].

________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:583:8:unused_fun
Function validate_scheduler_data/1 will never be called.
________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:695:7:pattern_match_cov
The pattern
variable_error

can never match, because previous clauses completely cover the type

  {:ok,
   %Jido.Signal{
     :data => _,
     :datacontenttype => nil | binary(),
     :dataschema => nil | binary(),
     :id => binary(),
     :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
     :source => binary(),
     :specversion => <<_::40>>,
     :subject => nil | binary(),
     :time => nil | binary(),
     :type => binary()
   }}
.

________________________________________________________________________________
done (warnings were emitted)
Halting VM with exit status 2
