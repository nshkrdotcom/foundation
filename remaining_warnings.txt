lib/jido_system.ex:195:11:pattern_match
The pattern can never match the type.

Pattern:
:ok

Type:
{:error, :server_not_found} | {:ok, binary()}

________________________________________________________________________________
lib/jido_system.ex:316:11:pattern_match
The pattern can never match the type.

Pattern:
:ok

Type:
{:error, :server_not_found} | {:ok, binary()}

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:63:callback_spec_arg_type_mismatch
The @spec type for the 1st argument is not a
supertype of the expected type for the mount/2 callback
in the Jido.Agent behaviour.

Success type:
%Jido.Agent.Server.State{
  :agent => %Jido.Agent{
    :actions => [atom()],
    :category => nil | binary(),
    :description => nil | binary(),
    :dirty_state? => boolean(),
    :id => nil | binary(),
    :name => nil | binary(),
    :pending_instructions => nil | :queue.queue(_),
    :result => _,
    :runner => atom(),
    :schema => nil | Keyword.t(),
    :state => map(),
    :tags => nil | [binary()],
    :vsn => nil | binary()
  },
  :child_supervisor => nil | pid(),
  :current_signal => %Jido.Signal{
    :data => _,
    :datacontenttype => nil | binary(),
    :dataschema => nil | binary(),
    :id => binary(),
    :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
    :source => binary(),
    :specversion => binary(),
    :subject => nil | binary(),
    :time => nil | binary(),
    :type => binary()
  },
  :current_signal_type => atom(),
  :dispatch => [
    {:err, {atom(), Keyword.t()}}
    | {:log, {atom(), Keyword.t()}}
    | {:out, {atom(), Keyword.t()}}
  ],
  :journal => %Jido.Signal.Journal{:adapter => atom(), :adapter_pid => nil | pid()},
  :log_level =>
    :alert | :critical | :debug | :emergency | :error | :info | :notice | :warning,
  :max_queue_size => non_neg_integer(),
  :mode => :auto | :step,
  :opts => Keyword.t(),
  :orchestrator_pid => nil | pid(),
  :parent_pid => nil | pid(),
  :pending_signals => :queue.queue(_),
  :registry => atom(),
  :reply_refs => %{binary() => {pid(), _}},
  :router => %Jido.Signal.Router.Router{
    :route_count => non_neg_integer(),
    :trie => %Jido.Signal.Router.TrieNode{
      :handlers =>
        nil
        | %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
      :segments => %{
        binary() => %Jido.Signal.Router.TrieNode{
          :handlers => nil | map(),
          :segments => map(),
          :wildcards => [any()],
          _ => _
        }
      },
      :wildcards => [
        %Jido.Signal.Router.WildcardHandlers{
          :handlers => %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
          :type => :multi | :single
        }
      ]
    }
  },
  :skills => [
    %Jido.Skill{
      :category => nil | binary(),
      :description => nil | binary(),
      :name => binary(),
      :opts_key => atom(),
      :opts_schema => nil | map(),
      :signal_patterns => [binary()],
      :tags => [binary()],
      :vsn => nil | binary()
    }
  ],
  :status => :idle | :initializing | :paused | :planning | :running
}

Behaviour callback type:
%Jido.Agent{
  :actions => [atom()],
  :category => nil | binary(),
  :description => nil | binary(),
  :dirty_state? => boolean(),
  :id => nil | binary(),
  :name => nil | binary(),
  :pending_instructions => nil | :queue.queue(_),
  :result => _,
  :runner => atom(),
  :schema => nil | Keyword.t(),
  :state => map(),
  :tags => nil | [binary()],
  :vsn => nil | binary()
}

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:63:callback_spec_arg_type_mismatch
The @spec type for the 1st argument is not a
supertype of the expected type for the shutdown/2 callback
in the Jido.Agent behaviour.

Success type:
%Jido.Agent.Server.State{
  :agent => %Jido.Agent{
    :actions => [atom()],
    :category => nil | binary(),
    :description => nil | binary(),
    :dirty_state? => boolean(),
    :id => nil | binary(),
    :name => nil | binary(),
    :pending_instructions => nil | :queue.queue(_),
    :result => _,
    :runner => atom(),
    :schema => nil | Keyword.t(),
    :state => map(),
    :tags => nil | [binary()],
    :vsn => nil | binary()
  },
  :child_supervisor => nil | pid(),
  :current_signal => %Jido.Signal{
    :data => _,
    :datacontenttype => nil | binary(),
    :dataschema => nil | binary(),
    :id => binary(),
    :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
    :source => binary(),
    :specversion => binary(),
    :subject => nil | binary(),
    :time => nil | binary(),
    :type => binary()
  },
  :current_signal_type => atom(),
  :dispatch => [
    {:err, {atom(), Keyword.t()}}
    | {:log, {atom(), Keyword.t()}}
    | {:out, {atom(), Keyword.t()}}
  ],
  :journal => %Jido.Signal.Journal{:adapter => atom(), :adapter_pid => nil | pid()},
  :log_level =>
    :alert | :critical | :debug | :emergency | :error | :info | :notice | :warning,
  :max_queue_size => non_neg_integer(),
  :mode => :auto | :step,
  :opts => Keyword.t(),
  :orchestrator_pid => nil | pid(),
  :parent_pid => nil | pid(),
  :pending_signals => :queue.queue(_),
  :registry => atom(),
  :reply_refs => %{binary() => {pid(), _}},
  :router => %Jido.Signal.Router.Router{
    :route_count => non_neg_integer(),
    :trie => %Jido.Signal.Router.TrieNode{
      :handlers =>
        nil
        | %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
      :segments => %{
        binary() => %Jido.Signal.Router.TrieNode{
          :handlers => nil | map(),
          :segments => map(),
          :wildcards => [any()],
          _ => _
        }
      },
      :wildcards => [
        %Jido.Signal.Router.WildcardHandlers{
          :handlers => %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
          :type => :multi | :single
        }
      ]
    }
  },
  :skills => [
    %Jido.Skill{
      :category => nil | binary(),
      :description => nil | binary(),
      :name => binary(),
      :opts_key => atom(),
      :opts_schema => nil | map(),
      :signal_patterns => [binary()],
      :tags => [binary()],
      :vsn => nil | binary()
    }
  ],
  :status => :idle | :initializing | :paused | :planning | :running
}

Behaviour callback type:
%Jido.Agent{
  :actions => [atom()],
  :category => nil | binary(),
  :description => nil | binary(),
  :dirty_state? => boolean(),
  :id => nil | binary(),
  :name => nil | binary(),
  :pending_instructions => nil | :queue.queue(_),
  :result => _,
  :runner => atom(),
  :schema => nil | Keyword.t(),
  :state => map(),
  :tags => nil | [binary()],
  :vsn => nil | binary()
}

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:63:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.CoordinatorAgent.do_validate/3

Success typing:
@spec do_validate(t(), map(), :elixir.keyword()) :: map_result()

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:63:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Agents.CoordinatorAgent.handle_signal/2

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:63:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.CoordinatorAgent.on_error/2

Success typing:
@spec on_error(t(), any()) :: agent_result()

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:63:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.CoordinatorAgent.pending?/1

Success typing:
@spec pending?(t()) :: non_neg_integer()

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:63:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.CoordinatorAgent.reset/1

Success typing:
@spec reset(t()) :: agent_result()

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:63:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Agents.CoordinatorAgent.transform_result/3

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:143:7:pattern_match_cov
The pattern
variable_error

can never match, because previous clauses completely cover the type
{:ok, _}.

________________________________________________________________________________
lib/jido_system/agents/coordinator_agent.ex:511:15:pattern_match
The pattern can never match the type.

Pattern:
:failed

Type:
:cancelled

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:57:callback_spec_arg_type_mismatch
The @spec type for the 1st argument is not a
supertype of the expected type for the mount/2 callback
in the Jido.Agent behaviour.

Success type:
%Jido.Agent.Server.State{
  :agent => %Jido.Agent{
    :actions => [atom()],
    :category => nil | binary(),
    :description => nil | binary(),
    :dirty_state? => boolean(),
    :id => nil | binary(),
    :name => nil | binary(),
    :pending_instructions => nil | :queue.queue(_),
    :result => _,
    :runner => atom(),
    :schema => nil | Keyword.t(),
    :state => map(),
    :tags => nil | [binary()],
    :vsn => nil | binary()
  },
  :child_supervisor => nil | pid(),
  :current_signal => %Jido.Signal{
    :data => _,
    :datacontenttype => nil | binary(),
    :dataschema => nil | binary(),
    :id => binary(),
    :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
    :source => binary(),
    :specversion => binary(),
    :subject => nil | binary(),
    :time => nil | binary(),
    :type => binary()
  },
  :current_signal_type => atom(),
  :dispatch => [
    {:err, {atom(), Keyword.t()}}
    | {:log, {atom(), Keyword.t()}}
    | {:out, {atom(), Keyword.t()}}
  ],
  :journal => %Jido.Signal.Journal{:adapter => atom(), :adapter_pid => nil | pid()},
  :log_level =>
    :alert | :critical | :debug | :emergency | :error | :info | :notice | :warning,
  :max_queue_size => non_neg_integer(),
  :mode => :auto | :step,
  :opts => Keyword.t(),
  :orchestrator_pid => nil | pid(),
  :parent_pid => nil | pid(),
  :pending_signals => :queue.queue(_),
  :registry => atom(),
  :reply_refs => %{binary() => {pid(), _}},
  :router => %Jido.Signal.Router.Router{
    :route_count => non_neg_integer(),
    :trie => %Jido.Signal.Router.TrieNode{
      :handlers =>
        nil
        | %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
      :segments => %{
        binary() => %Jido.Signal.Router.TrieNode{
          :handlers => nil | map(),
          :segments => map(),
          :wildcards => [any()],
          _ => _
        }
      },
      :wildcards => [
        %Jido.Signal.Router.WildcardHandlers{
          :handlers => %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
          :type => :multi | :single
        }
      ]
    }
  },
  :skills => [
    %Jido.Skill{
      :category => nil | binary(),
      :description => nil | binary(),
      :name => binary(),
      :opts_key => atom(),
      :opts_schema => nil | map(),
      :signal_patterns => [binary()],
      :tags => [binary()],
      :vsn => nil | binary()
    }
  ],
  :status => :idle | :initializing | :paused | :planning | :running
}

Behaviour callback type:
%Jido.Agent{
  :actions => [atom()],
  :category => nil | binary(),
  :description => nil | binary(),
  :dirty_state? => boolean(),
  :id => nil | binary(),
  :name => nil | binary(),
  :pending_instructions => nil | :queue.queue(_),
  :result => _,
  :runner => atom(),
  :schema => nil | Keyword.t(),
  :state => map(),
  :tags => nil | [binary()],
  :vsn => nil | binary()
}

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:57:callback_spec_arg_type_mismatch
The @spec type for the 1st argument is not a
supertype of the expected type for the shutdown/2 callback
in the Jido.Agent behaviour.

Success type:
%Jido.Agent.Server.State{
  :agent => %Jido.Agent{
    :actions => [atom()],
    :category => nil | binary(),
    :description => nil | binary(),
    :dirty_state? => boolean(),
    :id => nil | binary(),
    :name => nil | binary(),
    :pending_instructions => nil | :queue.queue(_),
    :result => _,
    :runner => atom(),
    :schema => nil | Keyword.t(),
    :state => map(),
    :tags => nil | [binary()],
    :vsn => nil | binary()
  },
  :child_supervisor => nil | pid(),
  :current_signal => %Jido.Signal{
    :data => _,
    :datacontenttype => nil | binary(),
    :dataschema => nil | binary(),
    :id => binary(),
    :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
    :source => binary(),
    :specversion => binary(),
    :subject => nil | binary(),
    :time => nil | binary(),
    :type => binary()
  },
  :current_signal_type => atom(),
  :dispatch => [
    {:err, {atom(), Keyword.t()}}
    | {:log, {atom(), Keyword.t()}}
    | {:out, {atom(), Keyword.t()}}
  ],
  :journal => %Jido.Signal.Journal{:adapter => atom(), :adapter_pid => nil | pid()},
  :log_level =>
    :alert | :critical | :debug | :emergency | :error | :info | :notice | :warning,
  :max_queue_size => non_neg_integer(),
  :mode => :auto | :step,
  :opts => Keyword.t(),
  :orchestrator_pid => nil | pid(),
  :parent_pid => nil | pid(),
  :pending_signals => :queue.queue(_),
  :registry => atom(),
  :reply_refs => %{binary() => {pid(), _}},
  :router => %Jido.Signal.Router.Router{
    :route_count => non_neg_integer(),
    :trie => %Jido.Signal.Router.TrieNode{
      :handlers =>
        nil
        | %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
      :segments => %{
        binary() => %Jido.Signal.Router.TrieNode{
          :handlers => nil | map(),
          :segments => map(),
          :wildcards => [any()],
          _ => _
        }
      },
      :wildcards => [
        %Jido.Signal.Router.WildcardHandlers{
          :handlers => %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
          :type => :multi | :single
        }
      ]
    }
  },
  :skills => [
    %Jido.Skill{
      :category => nil | binary(),
      :description => nil | binary(),
      :name => binary(),
      :opts_key => atom(),
      :opts_schema => nil | map(),
      :signal_patterns => [binary()],
      :tags => [binary()],
      :vsn => nil | binary()
    }
  ],
  :status => :idle | :initializing | :paused | :planning | :running
}

Behaviour callback type:
%Jido.Agent{
  :actions => [atom()],
  :category => nil | binary(),
  :description => nil | binary(),
  :dirty_state? => boolean(),
  :id => nil | binary(),
  :name => nil | binary(),
  :pending_instructions => nil | :queue.queue(_),
  :result => _,
  :runner => atom(),
  :schema => nil | Keyword.t(),
  :state => map(),
  :tags => nil | [binary()],
  :vsn => nil | binary()
}

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:57:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.MonitorAgent.do_validate/3

Success typing:
@spec do_validate(t(), map(), :elixir.keyword()) :: map_result()

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:57:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Agents.MonitorAgent.handle_signal/2

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:57:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.MonitorAgent.on_error/2

Success typing:
@spec on_error(t(), any()) :: agent_result()

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:57:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.MonitorAgent.pending?/1

Success typing:
@spec pending?(t()) :: non_neg_integer()

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:57:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.MonitorAgent.reset/1

Success typing:
@spec reset(t()) :: agent_result()

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:57:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Agents.MonitorAgent.transform_result/3

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:136:7:pattern_match_cov
The pattern
variable_error

can never match, because previous clauses completely cover the type
{:ok, _}.

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:373:46:no_return
The created anonymous function has no local return.
________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:375:11:pattern_match
The pattern can never match the type.

Pattern:
[{_pid, _metadata}]

Type:
:error | {:ok, {pid(), map()}}

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:384:12:pattern_match
The pattern can never match the type.

Pattern:
[]

Type:
:error | {:ok, {pid(), map()}}

________________________________________________________________________________
lib/jido_system/agents/monitor_agent.ex:412:7:pattern_match_cov
The pattern
:variable_

can never match, because previous clauses completely cover the type
binary().

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:49:callback_spec_arg_type_mismatch
The @spec type for the 1st argument is not a
supertype of the expected type for the mount/2 callback
in the Jido.Agent behaviour.

Success type:
%Jido.Agent.Server.State{
  :agent => %Jido.Agent{
    :actions => [atom()],
    :category => nil | binary(),
    :description => nil | binary(),
    :dirty_state? => boolean(),
    :id => nil | binary(),
    :name => nil | binary(),
    :pending_instructions => nil | :queue.queue(_),
    :result => _,
    :runner => atom(),
    :schema => nil | Keyword.t(),
    :state => map(),
    :tags => nil | [binary()],
    :vsn => nil | binary()
  },
  :child_supervisor => nil | pid(),
  :current_signal => %Jido.Signal{
    :data => _,
    :datacontenttype => nil | binary(),
    :dataschema => nil | binary(),
    :id => binary(),
    :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
    :source => binary(),
    :specversion => binary(),
    :subject => nil | binary(),
    :time => nil | binary(),
    :type => binary()
  },
  :current_signal_type => atom(),
  :dispatch => [
    {:err, {atom(), Keyword.t()}}
    | {:log, {atom(), Keyword.t()}}
    | {:out, {atom(), Keyword.t()}}
  ],
  :journal => %Jido.Signal.Journal{:adapter => atom(), :adapter_pid => nil | pid()},
  :log_level =>
    :alert | :critical | :debug | :emergency | :error | :info | :notice | :warning,
  :max_queue_size => non_neg_integer(),
  :mode => :auto | :step,
  :opts => Keyword.t(),
  :orchestrator_pid => nil | pid(),
  :parent_pid => nil | pid(),
  :pending_signals => :queue.queue(_),
  :registry => atom(),
  :reply_refs => %{binary() => {pid(), _}},
  :router => %Jido.Signal.Router.Router{
    :route_count => non_neg_integer(),
    :trie => %Jido.Signal.Router.TrieNode{
      :handlers =>
        nil
        | %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
      :segments => %{
        binary() => %Jido.Signal.Router.TrieNode{
          :handlers => nil | map(),
          :segments => map(),
          :wildcards => [any()],
          _ => _
        }
      },
      :wildcards => [
        %Jido.Signal.Router.WildcardHandlers{
          :handlers => %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
          :type => :multi | :single
        }
      ]
    }
  },
  :skills => [
    %Jido.Skill{
      :category => nil | binary(),
      :description => nil | binary(),
      :name => binary(),
      :opts_key => atom(),
      :opts_schema => nil | map(),
      :signal_patterns => [binary()],
      :tags => [binary()],
      :vsn => nil | binary()
    }
  ],
  :status => :idle | :initializing | :paused | :planning | :running
}

Behaviour callback type:
%Jido.Agent{
  :actions => [atom()],
  :category => nil | binary(),
  :description => nil | binary(),
  :dirty_state? => boolean(),
  :id => nil | binary(),
  :name => nil | binary(),
  :pending_instructions => nil | :queue.queue(_),
  :result => _,
  :runner => atom(),
  :schema => nil | Keyword.t(),
  :state => map(),
  :tags => nil | [binary()],
  :vsn => nil | binary()
}

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:49:callback_spec_arg_type_mismatch
The @spec type for the 1st argument is not a
supertype of the expected type for the shutdown/2 callback
in the Jido.Agent behaviour.

Success type:
%Jido.Agent.Server.State{
  :agent => %Jido.Agent{
    :actions => [atom()],
    :category => nil | binary(),
    :description => nil | binary(),
    :dirty_state? => boolean(),
    :id => nil | binary(),
    :name => nil | binary(),
    :pending_instructions => nil | :queue.queue(_),
    :result => _,
    :runner => atom(),
    :schema => nil | Keyword.t(),
    :state => map(),
    :tags => nil | [binary()],
    :vsn => nil | binary()
  },
  :child_supervisor => nil | pid(),
  :current_signal => %Jido.Signal{
    :data => _,
    :datacontenttype => nil | binary(),
    :dataschema => nil | binary(),
    :id => binary(),
    :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
    :source => binary(),
    :specversion => binary(),
    :subject => nil | binary(),
    :time => nil | binary(),
    :type => binary()
  },
  :current_signal_type => atom(),
  :dispatch => [
    {:err, {atom(), Keyword.t()}}
    | {:log, {atom(), Keyword.t()}}
    | {:out, {atom(), Keyword.t()}}
  ],
  :journal => %Jido.Signal.Journal{:adapter => atom(), :adapter_pid => nil | pid()},
  :log_level =>
    :alert | :critical | :debug | :emergency | :error | :info | :notice | :warning,
  :max_queue_size => non_neg_integer(),
  :mode => :auto | :step,
  :opts => Keyword.t(),
  :orchestrator_pid => nil | pid(),
  :parent_pid => nil | pid(),
  :pending_signals => :queue.queue(_),
  :registry => atom(),
  :reply_refs => %{binary() => {pid(), _}},
  :router => %Jido.Signal.Router.Router{
    :route_count => non_neg_integer(),
    :trie => %Jido.Signal.Router.TrieNode{
      :handlers =>
        nil
        | %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
      :segments => %{
        binary() => %Jido.Signal.Router.TrieNode{
          :handlers => nil | map(),
          :segments => map(),
          :wildcards => [any()],
          _ => _
        }
      },
      :wildcards => [
        %Jido.Signal.Router.WildcardHandlers{
          :handlers => %Jido.Signal.Router.NodeHandlers{
            :handlers => [
              %Jido.Signal.Router.HandlerInfo{
                :complexity => non_neg_integer(),
                :priority => non_neg_integer(),
                :target => _
              }
            ],
            :matchers => [
              %Jido.Signal.Router.PatternMatch{
                :complexity => non_neg_integer(),
                :match => (%Jido.Signal{
                             :data => _,
                             :datacontenttype => nil | binary(),
                             :dataschema => nil | binary(),
                             :id => binary(),
                             :jido_dispatch =>
                               nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
                             :source => binary(),
                             :specversion => binary(),
                             :subject => nil | binary(),
                             :time => nil | binary(),
                             :type => binary()
                           } ->
                             boolean()),
                :priority => non_neg_integer(),
                :target => _
              }
            ]
          },
          :type => :multi | :single
        }
      ]
    }
  },
  :skills => [
    %Jido.Skill{
      :category => nil | binary(),
      :description => nil | binary(),
      :name => binary(),
      :opts_key => atom(),
      :opts_schema => nil | map(),
      :signal_patterns => [binary()],
      :tags => [binary()],
      :vsn => nil | binary()
    }
  ],
  :status => :idle | :initializing | :paused | :planning | :running
}

Behaviour callback type:
%Jido.Agent{
  :actions => [atom()],
  :category => nil | binary(),
  :description => nil | binary(),
  :dirty_state? => boolean(),
  :id => nil | binary(),
  :name => nil | binary(),
  :pending_instructions => nil | :queue.queue(_),
  :result => _,
  :runner => atom(),
  :schema => nil | Keyword.t(),
  :state => map(),
  :tags => nil | [binary()],
  :vsn => nil | binary()
}

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:49:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.TaskAgent.do_validate/3

Success typing:
@spec do_validate(t(), map(), :elixir.keyword()) :: map_result()

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:49:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Agents.TaskAgent.handle_signal/2

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:49:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.TaskAgent.on_error/2

Success typing:
@spec on_error(t(), any()) :: agent_result()

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:49:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.TaskAgent.pending?/1

Success typing:
@spec pending?(t()) :: non_neg_integer()

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:49:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Agents.TaskAgent.reset/1

Success typing:
@spec reset(t()) :: agent_result()

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:49:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Agents.TaskAgent.transform_result/3

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:116:7:pattern_match_cov
The pattern
variable_error

can never match, because previous clauses completely cover the type
{:ok, _}.

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:190:7:pattern_match_cov
The pattern
variable_error

can never match, because previous clauses completely cover the type
{:ok, _}.

________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:196:7:callback_type_mismatch
Type mismatch for @callback on_error/2 in Jido.Agent behaviour.

Expected type:

  {:error,
   %Jido.Agent{
     :actions => [atom()],
     :category => nil | binary(),
     :description => nil | binary(),
     :dirty_state? => boolean(),
     :id => nil | binary(),
     :name => nil | binary(),
     :pending_instructions => nil | :queue.queue(_),
     :result => _,
     :runner => atom(),
     :schema => nil | Keyword.t(),
     :state => map(),
     :tags => nil | [binary()],
     :vsn => nil | binary()
   }}
  | {:ok,
     %Jido.Agent{
       :actions => [atom()],
       :category => nil | binary(),
       :description => nil | binary(),
       :dirty_state? => boolean(),
       :id => nil | binary(),
       :name => nil | binary(),
       :pending_instructions => nil | :queue.queue(_),
       :result => _,
       :runner => atom(),
       :schema => nil | Keyword.t(),
       :state => map(),
       :tags => nil | [binary()],
       :vsn => nil | binary()
     }}


Actual type:

  {:ok,
   %{
     :state => %{
       :current_task => nil,
       :error_count => _,
       :status => :idle | :paused | :recovering,
       _ => _
     },
     _ => _
   }, []}


________________________________________________________________________________
lib/jido_system/agents/task_agent.ex:232:7:pattern_match_cov
The pattern
variable_error

can never match, because previous clauses completely cover the type
{:ok, %{:state => %{:status => :recovering, _ => _}, _ => _}, []}.

________________________________________________________________________________
lib/jido_system/sensors/agent_performance_sensor.ex:32:contract_supertype
Type specification is a supertype of the success typing.

Function:
JidoSystem.Sensors.AgentPerformanceSensor.__sensor_metadata__/0

Type specification:
@spec __sensor_metadata__() :: map()

Success typing:
@spec __sensor_metadata__() :: %{:category => _, :description => _, :name => _, :schema => _, :tags => _, :vsn => _}

________________________________________________________________________________
lib/jido_system/sensors/agent_performance_sensor.ex:32:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Sensors.AgentPerformanceSensor.deliver_signal/1

Success typing:
@spec deliver_signal(map()) :: {:ok, Jido.Signal.t()} | {:error, any()}

________________________________________________________________________________
lib/jido_system/sensors/agent_performance_sensor.ex:32:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Sensors.AgentPerformanceSensor.mount/1

Extra type:
{:error, _}

Success typing:

  {:ok,
   %{
     :agent_metrics => %{},
     :last_analysis => %DateTime{
       :calendar => atom(),
       :day => pos_integer(),
       :hour => non_neg_integer(),
       :microsecond => {_, _},
       :minute => non_neg_integer(),
       :month => pos_integer(),
       :second => non_neg_integer(),
       :std_offset => integer(),
       :time_zone => binary(),
       :utc_offset => integer(),
       :year => integer(),
       :zone_abbr => binary()
     },
     :optimization_suggestions => %{},
     :performance_history => %{},
     :started_at => %DateTime{
       :calendar => atom(),
       :day => pos_integer(),
       :hour => non_neg_integer(),
       :microsecond => {_, _},
       :minute => non_neg_integer(),
       :month => pos_integer(),
       :second => non_neg_integer(),
       :std_offset => integer(),
       :time_zone => binary(),
       :utc_offset => integer(),
       :year => integer(),
       :zone_abbr => binary()
     },
     :monitoring_interval => non_neg_integer(),
     _ => _
   }}


________________________________________________________________________________
lib/jido_system/sensors/agent_performance_sensor.ex:32:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Sensors.AgentPerformanceSensor.on_before_deliver/2

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/sensors/agent_performance_sensor.ex:32:unknown_type
Unknown type: Jido.Sensor.sensor_result/0.
________________________________________________________________________________
lib/jido_system/sensors/agent_performance_sensor.ex:32:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Sensors.AgentPerformanceSensor.shutdown/1

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/sensors/agent_performance_sensor.ex:32:contract_supertype
Type specification is a supertype of the success typing.

Function:
JidoSystem.Sensors.AgentPerformanceSensor.to_json/0

Type specification:
@spec to_json() :: map()

Success typing:
@spec to_json() :: %{:category => _, :description => _, :name => _, :schema => _, :tags => _, :vsn => _}

________________________________________________________________________________
lib/jido_system/sensors/agent_performance_sensor.ex:81:7:callback_type_mismatch
Type mismatch for @callback deliver_signal/1 in Jido.Sensor behaviour.

Expected type:

  {:error, _}
  | {:ok,
     %Jido.Signal{
       :data => _,
       :datacontenttype => nil | binary(),
       :dataschema => nil | binary(),
       :id => binary(),
       :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
       :source => binary(),
       :specversion => binary(),
       :subject => nil | binary(),
       :time => nil | binary(),
       :type => binary()
     }}


Actual type:

  {:ok,
   {:error, <<_::64, _::size(8)>>}
   | {:ok,
      %Jido.Signal{
        :data => _,
        :datacontenttype => nil | binary(),
        :dataschema => nil | binary(),
        :id => binary(),
        :jido_dispatch => nil | [any()] | {_, _},
        :source => binary(),
        :specversion => <<_::40>>,
        :subject => nil | binary(),
        :time => nil | binary(),
        :type => binary()
      }}, _}


________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:49:contract_supertype
Type specification is a supertype of the success typing.

Function:
JidoSystem.Sensors.SystemHealthSensor.__sensor_metadata__/0

Type specification:
@spec __sensor_metadata__() :: map()

Success typing:
@spec __sensor_metadata__() :: %{:category => _, :description => _, :name => _, :schema => _, :tags => _, :vsn => _}

________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:49:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Sensors.SystemHealthSensor.deliver_signal/1

Extra type:
{:error, _}

Success typing:

  {:ok,
   {:error, <<_::64, _::size(8)>>}
   | {:ok,
      %Jido.Signal{
        :data => _,
        :datacontenttype => nil | binary(),
        :dataschema => nil | binary(),
        :id => binary(),
        :jido_dispatch => nil | [any()] | {_, _},
        :source => binary(),
        :specversion => <<_::40>>,
        :subject => nil | binary(),
        :time => nil | binary(),
        :type => binary()
      }}
   | %Jido.Signal{
       :data => _,
       :datacontenttype => nil | binary(),
       :dataschema => nil | binary(),
       :id => binary(),
       :jido_dispatch => nil | [{_, _}] | {atom(), [any()]},
       :source => binary(),
       :specversion => <<_::40>>,
       :subject => nil | binary(),
       :time => nil | binary(),
       :type => binary()
     }}


________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:49:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Sensors.SystemHealthSensor.mount/1

Extra type:
{:error, _}

Success typing:

  {:ok,
   %{
     :alert_cooldown => _,
     :baseline_metrics => %{},
     :collection_count => 0,
     :collection_interval => non_neg_integer(),
     :enable_anomaly_detection => _,
     :history_size => _,
     :last_alerts => %{},
     :last_metrics => %{},
     :metrics_history => [],
     :started_at => %DateTime{
       :calendar => atom(),
       :day => pos_integer(),
       :hour => non_neg_integer(),
       :microsecond => {_, _},
       :minute => non_neg_integer(),
       :month => pos_integer(),
       :second => non_neg_integer(),
       :std_offset => integer(),
       :time_zone => binary(),
       :utc_offset => integer(),
       :year => integer(),
       :zone_abbr => binary()
     },
     :thresholds => _,
     _ => _
   }}


________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:49:invalid_contract
The @spec for the function does not match the success typing of the function.

Function:
JidoSystem.Sensors.SystemHealthSensor.on_before_deliver/2

Success typing:
@spec on_before_deliver(Jido.Signal.t(), map()) :: {:ok, Jido.Signal.t()} | {:error, any()}

________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:49:unknown_type
Unknown type: Jido.Sensor.sensor_result/0.
________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:49:extra_range
The type specification has too many types for the function.

Function:
JidoSystem.Sensors.SystemHealthSensor.shutdown/1

Extra type:
{:error, _}

Success typing:
{:ok, _}

________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:49:contract_supertype
Type specification is a supertype of the success typing.

Function:
JidoSystem.Sensors.SystemHealthSensor.to_json/0

Type specification:
@spec to_json() :: map()

Success typing:
@spec to_json() :: %{:category => _, :description => _, :name => _, :schema => _, :tags => _, :vsn => _}

________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:166:7:callback_type_mismatch
Type mismatch for @callback on_before_deliver/2 in Jido.Sensor behaviour.

Expected type:

  {:error, _}
  | {:ok,
     %Jido.Signal{
       :data => _,
       :datacontenttype => nil | binary(),
       :dataschema => nil | binary(),
       :id => binary(),
       :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
       :source => binary(),
       :specversion => binary(),
       :subject => nil | binary(),
       :time => nil | binary(),
       :type => binary()
     }}


Actual type:
%{
  :data => %{:collection_count => _, :sensor_id => _, :sensor_uptime => integer(), _ => _},
  _ => _
}

________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:564:8:pattern_match_cov
The pattern
variable_scheduler_utilization

can never match, because previous clauses completely cover the type
[].

________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:578:8:pattern_match_cov
The pattern
variable__invalid_data

can never match, because previous clauses completely cover the type
[].

________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:583:8:unused_fun
Function validate_scheduler_data/1 will never be called.
________________________________________________________________________________
lib/jido_system/sensors/system_health_sensor.ex:695:7:pattern_match_cov
The pattern
variable_error

can never match, because previous clauses completely cover the type

  {:ok,
   %Jido.Signal{
     :data => _,
     :datacontenttype => nil | binary(),
     :dataschema => nil | binary(),
     :id => binary(),
     :jido_dispatch => nil | Keyword.t(Keyword.t()) | {atom(), Keyword.t()},
     :source => binary(),
     :specversion => <<_::40>>,
     :subject => nil | binary(),
     :time => nil | binary(),
     :type => binary()
   }}
.

________________________________________________________________________________
